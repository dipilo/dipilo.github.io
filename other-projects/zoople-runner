<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Zoople Chaser</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; color: white; font-family: sans-serif; }
    #gameCanvas { display: block; background: #111; }
    .overlay-level {
      position: absolute; top: 10px; width: 100%; text-align: center;
      font-size: 36px; font-weight: bold;
    }
    .overlay-timer {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      font-size: 120px; font-weight: bold;
    }
  </style>
</head>
<body>
<div class="overlay-level" id="levelDisplay">Level: 1</div>
<div class="overlay-timer" id="timerDisplay">10.0</div>
<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const WIDTH = canvas.width, HEIGHT = canvas.height;

// Load images\ const whiteImg = new Image(); whiteImg.src = '/images/zoople-chaser/zoopleWhite.png';
const purpleImg = new Image(); purpleImg.src = '/images/zoople-chaser/zooplePurple.png';

// Player
const player = { x: WIDTH/2, y: HEIGHT/2, r: 15, speed: 5 };

// Enemies
const enemies = [];
const enemyRadius = 15;
const enemySpeed = 2;

// Level
let level = 1;
const levelDuration = 10;
let startTime = performance.now();

// Keys
const keys = {};
document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

function spawnEnemy(atPos) {
  let x, y;
  if (!atPos) {
    x = Math.random()*(WIDTH-2*enemyRadius) + enemyRadius;
    y = Math.random()*(HEIGHT-2*enemyRadius) + enemyRadius;
  } else {
    const [avgX, avgY] = atPos;
    x = avgX + (Math.random()*200-100);
    y = avgY + (Math.random()*200-100);
    x = Math.max(enemyRadius, Math.min(WIDTH-enemyRadius, x));
    y = Math.max(enemyRadius, Math.min(HEIGHT-enemyRadius, y));
  }
  enemies.push({ x, y });
}

function averageEnemyPos() {
  const sum = enemies.reduce((a,e)=>{a[0]+=e.x; a[1]+=e.y; return a;},[0,0]);
  return [sum[0]/enemies.length, sum[1]/enemies.length];
}

// Prevent overlap: simple separation
function separateEnemies() {
  for (let i=0; i<enemies.length; i++) {
    for (let j=i+1; j<enemies.length; j++) {
      const a = enemies[i], b = enemies[j];
      const dx = b.x - a.x, dy = b.y - a.y;
      const dist = Math.hypot(dx, dy);
      if (dist < enemyRadius*2) {
        const overlap = enemyRadius*2 - dist;
        const ux = dx/dist, uy = dy/dist;
        a.x -= ux*overlap/2;
        a.y -= uy*overlap/2;
        b.x += ux*overlap/2;
        b.y += uy*overlap/2;
      }
    }
  }
}

// Initial spawn
spawnEnemy();

function resetGame() {
  level = 1; enemies.length = 0; spawnEnemy();
  player.x = WIDTH/2; player.y = HEIGHT/2;
  startTime = performance.now();
}

function update(delta) {
  // Player movement
  if (keys['w'] && player.y-player.r>0) player.y -= player.speed;
  if (keys['s'] && player.y+player.r<HEIGHT) player.y += player.speed;
  if (keys['a'] && player.x-player.r>0) player.x -= player.speed;
  if (keys['d'] && player.x+player.r<WIDTH) player.x += player.speed;

  // Enemies move toward player
  enemies.forEach(e => {
    const dx = player.x - e.x, dy = player.y - e.y;
    const dist = Math.hypot(dx, dy);
    if (dist>0) {
      e.x += (dx/dist)*enemySpeed;
      e.y += (dy/dist)*enemySpeed;
    }
  });

  separateEnemies();

  // Collision detect
  for (let e of enemies) {
    const d = Math.hypot(player.x-e.x, player.y-e.y);
    if (d < player.r+enemyRadius) {
      resetGame(); return;
    }
  }

  // Level timing
  const elapsed = (performance.now()-startTime)/1000;
  const remaining = Math.max(0,(levelDuration - elapsed).toFixed(1));
  document.getElementById('timerDisplay').textContent = remaining;
  document.getElementById('levelDisplay').textContent = `Level: ${level}`;

  if (elapsed >= levelDuration) {
    const avg = averageEnemyPos();
    level++;
    spawnEnemy(avg);
    startTime = performance.now();
  }
}

function draw() {
  ctx.clearRect(0,0,WIDTH,HEIGHT);
  // Draw player
  ctx.drawImage(whiteImg, player.x-player.r, player.y-player.r, player.r*2, player.r*2);
  // Draw enemies
  enemies.forEach(e => {
    ctx.drawImage(purpleImg, e.x-enemyRadius, e.y-enemyRadius, enemyRadius*2, enemyRadius*2);
  });
}

let last = performance.now();
function loop() {
  const now = performance.now();
  update((now-last)/1000);
  draw();
  last = now;
  requestAnimationFrame(loop);
}

// Start when images loaded
purpleImg.onload = () => whiteImg.onload = () => loop();
</script>
</body>
</html>
