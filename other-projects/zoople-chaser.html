<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Zoople Chaser</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; display:flex; align-items:center; justify-content:center; height:100vh; font-family:sans-serif; }
    #gameContainer { position:relative; width:800px; height:600px; }
    #gameCanvas { background:#111; display:block; }
    .overlay { position:absolute; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:20px; background:rgba(0,0,0,0.7); z-index:3; }
    #settings { display:none; z-index:4; }
    #mobilePause { display:none; z-index:5; color:#fff; font-size:24px; text-align:center; padding:20px; }
    button { padding:12px 24px; font-size:20px; background:rgba(255,255,255,0.1); color:#fff; border:2px solid #444; border-radius:6px; cursor:pointer; transition:background .2s; }
    button:hover { background:rgba(255,255,255,0.2); }
    .toggle, .dropdown { display:inline-block; }
    .toggle { position:relative; width:50px; height:24px; }
    .toggle input { display:none; }
    .track { position:absolute; inset:0; background:#444; border-radius:12px; transition:background .2s; }
    .thumb { position:absolute; top:2px; left:2px; width:20px; height:20px; background:#fff; border-radius:50%; transition:transform .2s; }
    .toggle input:checked + .track { background:#4caf50; }
    .toggle input:checked + .track + .thumb { transform:translateX(26px); }
    .dropdown { position:relative; }
    .dropdown select { appearance:none; padding:10px 40px 10px 16px; font-size:18px; background:rgba(255,255,255,0.1); color:#fff; border:2px solid #444; border-radius:6px; cursor:pointer; }
    .dropdown::after { content:'â–¾'; position:absolute; top:50%; right:12px; transform:translateY(-50%); color:#fff; pointer-events:none; }
    #joystick { position:absolute; width:100px; height:100px; border:2px solid #fff; border-radius:50%; display:none; z-index:4; }
    #stick { position:absolute; width:40px; height:40px; background:rgba(255,255,255,0.5); border-radius:50%; left:30px; top:30px; }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="menu" class="overlay">
      <button id="playBtn">Play</button>
      <button id="settingsBtn">Settings</button>
      <button id="quitBtn">Quit</button>
    </div>
    <div id="settings" class="overlay">
      <h2 style="color:#fff; margin:0;">Settings</h2>
      <div style="color:#fff; display:flex; align-items:center; gap:10px;"><span>Physics Player</span>
        <label class="toggle"><input type="checkbox" id="physPlayer" /><div class="track"></div><div class="thumb"></div></label>
      </div>
      <div style="color:#fff; display:flex; align-items:center; gap:10px;"><span>Physics Enemies</span>
        <label class="toggle"><input type="checkbox" id="physEnemies" checked /><div class="track"></div><div class="thumb"></div></label>
      </div>
      <div style="color:#fff; display:flex; align-items:center; gap:10px;"><span>Difficulty</span>
        <div class="dropdown"><select id="difficultySelect"><option value="Easy">Easy</option><option value="Hard" selected>Hard</option></select></div>
      </div>
      <div style="color:#fff; display:flex; align-items:center; gap:10px;"><span>Control Mode</span>
        <div class="dropdown"><select id="controlModeSelect"><option value="touch">Follow Finger</option><option value="joystick">Dynamic Joystick</option></select></div>
      </div>
      <button id="backBtn">Back</button>
    </div>
    <div id="mobilePause" class="overlay"><p>Rotate your device to landscape to play.</p></div>
    <div id="joystick"><div id="stick"></div></div>
  </div>

  <script>
  // Canvas setup
  const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // Settings & state
  let physPlayer=false, physEnemies=true, difficulty='Hard', controlMode='touch';
  let running=false, paused=false, spawnPause=0, pauseStart=0, pauseOffset=0;
  const isMobile = /Mobi|Android/i.test(navigator.userAgent);

  // Touch
  let touchActive=false, touchX=0, touchY=0;
  const joystick = document.getElementById('joystick'), stick = document.getElementById('stick');
  let joyCenterX=0, joyCenterY=0;

  // UI bindings
  document.getElementById('physPlayer').onchange = e=>physPlayer=e.target.checked;
  document.getElementById('physEnemies').onchange= e=>physEnemies=e.target.checked;
  document.getElementById('difficultySelect').onchange= e=>difficulty=e.target.value;
  document.getElementById('controlModeSelect').onchange=e=>controlMode=e.target.value;
  document.getElementById('playBtn').onclick = ()=>{
    if(running && paused){ paused=false; pauseOffset += performance.now() - pauseStart; toggle('menu', false); }
    else { startGame(); toggle('menu', false); }
  };
  document.getElementById('settingsBtn').onclick = ()=>{ toggle('menu', false); toggle('settings', true); };
  document.getElementById('backBtn').onclick     = ()=>{ toggle('settings', false); toggle('menu', true); };
  document.getElementById('quitBtn').onclick    = ()=> window.location.href='https://dipilo.github.io/other-projects';
  function toggle(id, show){ document.getElementById(id).style.display = show?'flex':'none'; }

  // Assets
  const playerImg = new Image(); playerImg.src='/images/zoople-chaser/zoopleWhite.png';
  const enemyImg  = new Image(); enemyImg.src ='/images/zoople-chaser/zooplePurple.png';
  const dingSound = new Audio('/sounds/ding.mp3');

  // Params
  const MAX_SPEED_P=400, MAX_SPEED_E=250;
  const STEER_FORCE_P=8000, STEER_FORCE_E=6000;
  const DAMPING=0.92;
  const INTERCEPT_CONE = Math.cos(Math.PI/6);
  const SEPARATION_RADIUS=40, SEPARATION_FORCE=12000;

  // Entities & level
  const player = { x:W/2, y:H/2, r:15, velX:0, velY:0 };
  let enemies = [];
  const ER = 15;
  let level=1, levelDuration=10, levelStartTime=0;

  // Input
  const keys={};
  window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; if(e.key==='Escape' && running){ paused = !paused; if(paused) pauseStart=performance.now(); toggle('menu', paused);} });
  window.addEventListener('keyup',   e=>keys[e.key.toLowerCase()]=false);

  // Mouse
  let mouseDown=false, mouseX=0, mouseY=0;
  canvas.addEventListener('mousedown', e=>{ if(e.button===0){ mouseDown=true; updateMouse(e); }});
  window.addEventListener('mouseup', ()=>mouseDown=false);
  canvas.addEventListener('mousemove', updateMouse);
  function updateMouse(e){ const r=canvas.getBoundingClientRect(); mouseX=e.clientX-r.left; mouseY=e.clientY-r.top; }

  // Touch handlers
  canvas.addEventListener('touchstart', e=>{
    if(!isMobile) return;
    const t=e.touches[0], r=canvas.getBoundingClientRect();
    touchActive=true; touchX=t.clientX-r.left; touchY=t.clientY-r.top;
    if(controlMode==='joystick'){
      joyCenterX=touchX; joyCenterY=touchY;
      joystick.style.left=(joyCenterX-50)+'px'; joystick.style.top=(joyCenterY-50)+'px'; joystick.style.display='block';
    }
  });
  canvas.addEventListener('touchmove', e=>{
    if(!isMobile||!touchActive) return;
    const t=e.touches[0], r=canvas.getBoundingClientRect();
    touchX=t.clientX-r.left; touchY=t.clientY-r.top;
    if(controlMode==='joystick'){
      const dx=touchX-joyCenterX, dy=touchY-joyCenterY, d=Math.hypot(dx,dy), max=50;
      const ux=d?dx/d:0, uy=d?dy/d:0;
      const len=Math.min(d,max);
      stick.style.left=(50+ux*len-20)+'px'; stick.style.top=(50+uy*len-20)+'px';
    }
  });
  canvas.addEventListener('touchend', e=>{
    if(!isMobile) return;
    touchActive=false; joystick.style.display='none';
  });

  // Orientation check
  function checkOrientation(){
    if(isMobile && window.innerHeight>window.innerWidth){ document.getElementById('mobilePause').style.display='flex'; paused=true; }
    else { document.getElementById('mobilePause').style.display='none'; if(running&&!paused) toggle('menu',false); }
  }
  window.addEventListener('resize', checkOrientation);
  checkOrientation();

  // Helpers
  function clamp(o){ o.x=Math.max(o.r||ER,Math.min(W-(o.r||ER),o.x)); o.y=Math.max(o.r||ER,Math.min(H-(o.r||ER),o.y)); }
  function separateArray(arr, ds){ arr.forEach((a,i)=> arr.forEach((b,j)=>{
      if(i!==j){ const dx=a.x-b.x, dy=a.y-b.y, d=Math.hypot(dx,dy);
        if(d<SEPARATION_RADIUS && d>0){ const push=(SEPARATION_RADIUS-d)/d*SEPARATION_FORCE*ds;
          a.velX += (dx/d)*push; a.velY += (dy/d)*push;
        }
      }
  })); }

  function spawnEnemy(at){
    spawnPause=0.2; enemies.forEach(e=>{e.velX=0;e.velY=0;}); dingSound.play();
    let x,y;
    do{ x=Math.random()*(W-2*ER)+ER; y=Math.random()*(H-2*ER)+ER; }
    while(Math.hypot(x-player.x,y-player.y)<player.r*4);
    if(at){ x=at[0]+(Math.random()*200-100); y=at[1]+(Math.random()*200-100);
      x=Math.max(ER,Math.min(W-ER,x)); y=Math.max(ER,Math.min(H-ER,y));
    }
    enemies.push({x,y,velX:0,velY:0,intercept:Math.random()<0.5});
  }

  function resetGame(){ running=false; enemies=[]; player.x=W/2; player.y=H/2; player.velX=0; player.velY=0; level=1; pauseOffset=0; toggle('menu',true); }
  function startGame(){ resetGame(); spawnEnemy(); levelStartTime=performance.now(); running=true; paused=false; }

  function update(dt){ if(!running||paused) return; const ds=dt/1000;
    // Player input & steering
    let ax=0, ay=0;
    if(controlMode==='touch' && touchActive){
      const dx=touchX-player.x, dy=touchY-player.y, d=Math.hypot(dx,dy);
      if(d>0){ ax=dx/d; ay=dy/d; }
    } else {
      if(keys['w']) ay--;
      if(keys['s']) ay++;
      if(keys['a']) ax--;
      if(keys['d']) ax++;
      if(mouseDown){ const dx=mouseX-player.x, dy=mouseY-player.y, d=Math.hypot(dx,dy);
        if(d>0){ ax=dx/d; ay=dy/d; }
      }
    }
    if(physPlayer){
      const dvx=ax*MAX_SPEED_P - player.velX;
      const dvy=ay*MAX_SPEED_P - player.velY;
      const dvm=Math.hypot(dvx,dvy);
      const maxF = STEER_FORCE_P * ds;
      const sx = dvm>maxF ? dvx/dvm*maxF : dvx;
      const sy = dvm>maxF ? dvy/dvm*maxF : dvy;
      player.velX += sx; player.velY += sy;
      player.velX *= DAMPING; player.velY *= DAMPING;
      player.x += player.velX * ds;
      player.y += player.velY * ds;
    } else {
      player.x += ax * MAX_SPEED_P * ds;
      player.y += ay * MAX_SPEED_P * ds;
    }
    clamp(player);

    // Enemy steering & separation
    if(spawnPause > 0) spawnPause -= ds;
    else {
      enemies.forEach(e=>{
        // Determine target
        let tx = player.x, ty = player.y;
        if(difficulty==='Hard' && e.intercept){
          const leadT = 0.5;
          const ix = player.x + player.velX*leadT;
          const iy = player.y + player.velY*leadT;
          const distD = Math.hypot(player.x - e.x, player.y - e.y);
          const distI = Math.hypot(ix - e.x, iy - e.y);
          // Check cone or distance
          const ux_e = distD>0 ? (player.x - e.x)/distD : 0;
          const uy_e = distD>0 ? (player.y - e.y)/distD : 0;
          const pv = Math.hypot(player.velX, player.velY);
          const upx = pv>0 ? player.velX/pv : 0;
          const upy = pv>0 ? player.velY/pv : 0;
          const dot = ux_e*upx + uy_e*upy;
          if(!(distD < distI || dot > INTERCEPT_CONE)){
            tx = (player.x + ix)/2;
            ty = (player.y + iy)/2;
          }
        }
        const dx = tx - e.x, dy = ty - e.y;
        const d = Math.hypot(dx,dy);
        const ux = d>0 ? dx/d : 0;
        const uy = d>0 ? dy/d : 0;
        if(physEnemies){
          const dvx = ux*MAX_SPEED_E - e.velX;
          const dvy = uy*MAX_SPEED_E - e.velY;
          const dvm = Math.hypot(dvx,dvy);
          const maxF = STEER_FORCE_E * ds;
          const sx = dvm>maxF ? dvx/dvm*maxF : dvx;
          const sy = dvm>maxF ? dvy/dvm*maxF : dvy;
          e.velX += sx; e.velY += sy;
          e.velX *= DAMPING; e.velY *= DAMPING;
          e.x += e.velX * ds; e.y += e.velY * ds;
        } else {
          e.x += ux * MAX_SPEED_E * ds;
          e.y += uy * MAX_SPEED_E * ds;
        }
        clamp(e);
      });
      // Separation forces
      separateArray(enemies, ds);
    }

    // Collision
    if(enemies.some(e=>Math.hypot(player.x-e.x, player.y-e.y) < player.r + ER)) resetGame();

    // Level progression
    const elapsed = (performance.now() - pauseOffset - levelStartTime)/1000;
    if(elapsed >= levelDuration){
      const avgX = enemies.reduce((s,e)=>s+e.x,0)/enemies.length;
      const avgY = enemies.reduce((s,e)=>s+e.y,0)/enemies.length;
      level++;
      enemies.forEach(e=>e.intercept = Math.random()<0.5);
      spawnEnemy([avgX, avgY]);
      levelStartTime = performance.now() - pauseOffset;
    }
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    const elapsed = running ? (performance.now()-pauseOffset-levelStartTime)/1000 : 0;
    const rem = Math.max(0, levelDuration - Math.floor(elapsed));
    ctx.fillStyle='#222'; ctx.font='200px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(rem, W/2, H/2);
    ctx.fillStyle='#fff'; ctx.font='36px sans-serif'; ctx.textBaseline='top';
    ctx.fillText(`Level: ${level}`, W/2, 10);
    ctx.drawImage(playerImg, player.x-player.r, player.y-player.r, player.r*2, player.r*2);
    enemies.forEach(e=>{
      ctx.drawImage(enemyImg, e.x-ER, e.y-ER, ER*2, ER*2);
    });
  }

  // Main loop
  let last = performance.now();
  (function loop(){
    const now = performance.now();
    const dt = now - last;
    update(dt);
    draw();
    last = now;
    requestAnimationFrame(loop);
  })();

  </script>
</body>
</html>
