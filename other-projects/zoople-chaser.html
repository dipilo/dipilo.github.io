<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Zoople Chaser</title>
  <style>
    html, body {
      margin: 0; padding: 0; background: #000;
      width: 100%; height: 100%; overflow: hidden;
      display: flex; align-items: center; justify-content: center;
    }
    #gameContainer {
      width: 800px; height: 600px;
      margin: 20px auto;
      position: relative;
    }
    #gameCanvas {
      width: 100%; height: 100%; background: #111;
      display: block;
    }
    .overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      gap: 20px; background: rgba(0,0,0,0.7);
      z-index: 10;
    }
    #settings { display: none; }
    #pauseBtn {
      position: absolute; top: 10px; right: 10px;
      padding: 6px 12px; font-size: 14px;
      background: rgba(255,255,255,0.2);
      border: none; border-radius: 4px;
      color: #fff; cursor: pointer; z-index: 15;
    }
    #mobilePause {
      position: absolute; top: 0; left: 0; width:100%; height:100%;
      display: none; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.5); color: #fff; font-size: 24px;
      z-index: 20;
    }
    button, select {
      padding: 10px 20px; font-size: 18px;
      background: rgba(255,255,255,0.1); color: #fff;
      border: 2px solid #444; border-radius: 6px;
      cursor: pointer;
    }
    button:hover, select:hover { background: rgba(255,255,255,0.2); }
    .dropdown { position: relative; }
    .dropdown select {
      appearance: none; padding-right: 40px;
      background: #444; color: #fff;
    }
    .dropdown::after {
      content: '▾'; position: absolute; top: 50%; right: 12px;
      transform: translateY(-50%); color: #fff;
      pointer-events: none;
    }
    .toggle { position: relative; width:50px; height:24px; }
    .toggle input { display: none; }
    .track {
      position: absolute; top:0; left:0; right:0; bottom:0;
      background: #444; border-radius: 12px;
      transition: background 0.2s;
    }
    .thumb {
      position: absolute; top:2px; left:2px;
      width:20px; height:20px; background: #fff;
      border-radius: 50%; transition: transform 0.2s;
    }
    .toggle input:checked + .track { background: #4caf50; }
    .toggle input:checked + .track + .thumb {
      transform: translateX(26px);
    }
    #joystick {
      position: absolute; width:100px; height:100px;
      border:2px solid #fff; border-radius:50%; display:none;
      z-index: 12;
    }
    #stick {
      position: absolute; width:40px; height:40px;
      background: rgba(255,255,255,0.5); border-radius:50%;
      left:30px; top:30px;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <button id="pauseBtn">Pause</button>

    <div id="menu" class="overlay">
      <button id="playBtn">Play</button>
      <button id="settingsBtn">Settings</button>
      <button id="quitBtn">Quit</button>
    </div>

    <div id="settings" class="overlay">
      <h2 style="color:#fff; margin:0;">Settings</h2>
      <div style="color:#fff; display:flex; align-items:center; gap:10px;">
        <span>Physics Player</span>
        <label class="toggle">
          <input type="checkbox" id="physPlayer">
          <div class="track"></div><div class="thumb"></div>
        </label>
      </div>
      <div style="color:#fff; display:flex; align-items:center; gap:10px;">
        <span>Physics Enemies</span>
        <label class="toggle">
          <input type="checkbox" id="physEnemies" checked>
          <div class="track"></div><div class="thumb"></div>
        </label>
      </div>
      <div style="color:#fff; display:flex; align-items:center; gap:10px;">
        <span>Difficulty</span>
        <div class="dropdown">
          <select id="difficultySelect">
            <option value="Hard" selected>Hard</option>
            <option value="Easy">Easy</option>
          </select>
        </div>
      </div>
      <div style="color:#fff; display:flex; align-items:center; gap:10px;">
        <span>Control Mode</span>
        <div class="dropdown">
          <select id="controlModeSelect">
            <option value="touch">Follow Finger</option>
            <option value="joystick">Dynamic Joystick</option>
          </select>
        </div>
      </div>
      <button id="backBtn">Back</button>
    </div>

    <div id="mobilePause"><p>Portrait paused. Rotate to landscape.</p></div>
    <div id="joystick"><div id="stick"></div></div>
  </div>

  <script>
  const container=document.getElementById('gameContainer');
  function scaleFit(){
    const scale=Math.min(window.innerWidth/800, window.innerHeight/600);
    container.style.transform=`scale(${scale})`;
  }
  window.addEventListener('resize',scaleFit);
  scaleFit();

  const canvas=document.getElementById('gameCanvas'), ctx=canvas.getContext('2d');
  const W=800,H=600;
  let physPlayer=false, physEnemies=true, difficulty='Hard', controlMode='touch';
  let running=false, paused=false, spawnPause=0, pauseStart=0, pauseOffset=0;
  const isMobile=/Mobi|Android/i.test(navigator.userAgent);

  document.getElementById('pauseBtn').onclick=()=>{
    if(running){
      paused=!paused;
      document.getElementById('menu').style.display = paused ? 'flex' : 'none';
      if(paused) pauseStart = performance.now();
    }
  };

  // UI bindings
  document.getElementById('physPlayer').onchange = e => physPlayer = e.target.checked;
  document.getElementById('physEnemies').onchange = e => physEnemies = e.target.checked;
  document.getElementById('difficultySelect').onchange = e => difficulty = e.target.value;
  document.getElementById('controlModeSelect').onchange = e => controlMode = e.target.value;

  document.getElementById('playBtn').onclick = () => {
    if(running && paused){
      paused = false;
      pauseOffset += performance.now() - pauseStart;
      document.getElementById('menu').style.display = 'none';
    } else {
      startGame();
      document.getElementById('menu').style.display = 'none';
    }
  };
  document.getElementById('settingsBtn').onclick = () => {
    document.getElementById('settings').style.display = 'flex';
    document.getElementById('menu').style.display = 'none';
  };
  document.getElementById('backBtn').onclick = () => {
    document.getElementById('settings').style.display = 'none';
    document.getElementById('menu').style.display = 'flex';
  };
  document.getElementById('quitBtn').onclick = () => window.location.href = 'https://dipilo.github.io/other-projects';

  const playerImg = new Image(); playerImg.src = '/images/zoople-chaser/zoopleWhite.png';
  const enemyImg  = new Image(); enemyImg.src  = '/images/zoople-chaser/zooplePurple.png';
  const dingSound = new Audio('/sounds/ding.mp3');

  const MAX_P = 400, MAX_E = 250;
  const STEER_P = 15000, STEER_E = 12000;
  const DAMP    = 0.95;
  const ICONE  = Math.cos(Math.PI/6);
  const SEP_R  = 40, SEP_F = 15000;

  const player = { x: W/2, y: H/2, r: 15, velX: 0, velY: 0 };
  let enemies = [];
  const ER = 15;
  let level = 1, levelDuration = 10, levelStartTime = 0;

  // Input
  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    if(e.key === 'Escape' && running){
      paused = !paused;
      document.getElementById('menu').style.display = paused ? 'flex' : 'none';
      if(paused) pauseStart = performance.now();
    }
  });
  window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

  let mouseDown = false, mouseX = 0, mouseY = 0;
  canvas.addEventListener('mousedown', e => { mouseDown = true; updateMouse(e); });
  window.addEventListener('mouseup', () => mouseDown = false);
  canvas.addEventListener('mousemove', updateMouse);
  function updateMouse(e) {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
  }

  // Touch
  let touchActive = false, touchX = 0, touchY = 0;
  const joystick = document.getElementById('joystick');
  const stickElem = document.getElementById('stick');
  let joyCX = 0, joyCY = 0;
  canvas.addEventListener('touchstart', e => {
    if(!isMobile) return;
    const t = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    touchActive = true;
    touchX = t.clientX - rect.left;
    touchY = t.clientY - rect.top;
    if(controlMode === 'joystick'){
      joyCX = touchX;
      joyCY = touchY;
      joystick.style.left = `${joyCX-50}px`;
      joystick.style.top = `${joyCY-50}px`;
      joystick.style.display = 'block';
    }
  });
  canvas.addEventListener('touchmove', e => {
    if(!isMobile || !touchActive) return;
    const t = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    touchX = t.clientX - rect.left;
    touchY = t.clientY - rect.top;
    if(controlMode === 'joystick'){
      const dx = touchX-joyCX;
      const dy = touchY-joyCY;
      const d = Math.hypot(dx, dy);
      const ux = d ? dx/d : 0;
      const uy = d ? dy/d : 0;
      const len = Math.min(d, 50);
      stickElem.style.left = `${50+ux*len-20}px`;
      stickElem.style.top  = `${50+uy*len-20}px`;
    }
  });
  canvas.addEventListener('touchend', () => {
    touchActive = false;
    joystick.style.display = 'none';
  });

  function checkPortrait(){
    const overlay = document.getElementById('mobilePause');
    if(isMobile && window.innerHeight > window.innerWidth){
      overlay.style.display = 'flex';
      paused = true;
      document.getElementById('menu').style.display = 'flex';
    } else overlay.style.display = 'none';
  }
  window.addEventListener('resize', checkPortrait);
  checkPortrait();

  function clamp(o){
    o.x = Math.max(o.r||ER, Math.min(W-(o.r||ER), o.x));
    o.y = Math.max(o.r||ER, Math.min(H-(o.r||ER), o.y));
  }
  function separate(arr, ds){
    arr.forEach((a,i) => arr.forEach((b,j) => {
      if(i!==j){
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        const d = Math.hypot(dx, dy);
        if(d < SEP_R && d>0){
          const push = (SEP_R-d)/d * SEP_F * ds;
          a.velX += dx/d * push;
          a.velY += dy/d * push;
        }
      }
    }));
  }

  function spawnEnemy(at){
    spawnPause = 0.2;
    enemies.forEach(e=>{ e.velX=0; e.velY=0; });
    dingSound.play();
    let x, y;
    do{
      x = Math.random()*(W-2*ER)+ER;
      y = Math.random()*(H-2*ER)+ER;
    } while(Math.hypot(x-player.x,y-player.y) < player.r*4);
    if(at){
      x = at[0] + (Math.random()*200-100);
      y = at[1] + (Math.random()*200-100);
      x = Math.max(ER, Math.min(W-ER, x));
      y = Math.max(ER, Math.min(H-ER, y));
    }
    enemies.push({ x, y, velX:0, velY:0, intercept: Math.random()<0.5 });
  }

  function resetGame(){
    running=false;
    enemies=[];
    player.x=W/2; player.y=H/2;
    player.velX=0; player.velY=0;
    level=1;
    pauseOffset=0;
    document.getElementById('menu').style.display='flex';
  }
  function startGame(){
    resetGame();
    spawnEnemy();
    levelStartTime = performance.now();
    running=true; paused=false;
    document.getElementById('menu').style.display='none';
  }

  function update(dt){
    if(!running || paused) return;
    const ds = dt/1000;
    let ax=0, ay=0;
    if(controlMode==='joystick' && touchActive){
      const dx=(touchX-joyCX)/50;
      const dy=(touchY-joyCY)/50;
      const mag=Math.hypot(dx,dy);
      if(mag>0){ ax=dx/mag; ay=dy/mag; }
    } else if(controlMode==='touch' && touchActive){
      const dx=touchX-player.x;
      const dy=touchY-player.y;
      const d=Math.hypot(dx,dy);
      if(d>0){ ax=dx/d; ay=dy/d; }
    } else {
      if(keys['w']) ay--;
      if(keys['s']) ay++;
      if(keys['a']) ax--;
      if(keys['d']) ax++;
      if(mouseDown){
        const dx=mouseX-player.x;
        const dy=mouseY-player.y;
        const d=Math.hypot(dx,dy);
        if(d>0){ ax=dx/d; ay=dy/d; }
      }
    }
    if(physPlayer){
      const dvx=ax*MAX_P-player.velX;
      const dvy=ay*MAX_P-player.velY;
      const dvm=Math.hypot(dvx,dvy);
      const maxF=STEER_P*ds;
      const sx=dvm>maxF?dvx/dvm*maxF:dvx;
      const sy=dvm>maxF?dvy/dvm*maxF:dvy;
      player.velX+=sx; player.velY+=sy;
      player.velX*=DAMP; player.velY*=DAMP;
      player.x+=player.velX*ds;
      player.y+=player.velY*ds;
    } else {
      player.x+=ax*MAX_P*ds;
      player.y+=ay*MAX_P*ds;
    }
    clamp(player);

    if(spawnPause>0) spawnPause-=ds;
    else {
      enemies.forEach(e=>{
        let tx=player.x, ty=player.y;
        if(difficulty==='Hard' && e.intercept){
          const lt=0.5;
          const ix=player.x+player.velX*lt;
          const iy=player.y+player.velY*lt;
          const distD=Math.hypot(player.x-e.x,player.y-e.y);
          const distI=Math.hypot(ix-e.x,iy-e.y);
          const ux_e=distD?(player.x-e.x)/distD:0;
          const uy_e=distD?(player.y-e.y)/distD:0;
          const pv=Math.hypot(player.velX,player.velY);
          const upx=pv?player.velX/pv:0;
          const upy=pv?player.velY/pv:0;
          const dot=ux_e*upx+uy_e*upy;
          if(!(distD<distI || dot>ICONE)){
            tx=(player.x+ix)/2;
            ty=(player.y+iy)/2;
          }
        }
        const dx=tx-e.x, dy=ty-e.y;
        const d=Math.hypot(dx,dy);
        const ux=d?dx/d:0, uy=d?dy/d:0;
        if(physEnemies){
          const dvx=ux*MAX_E-e.velX;
          const dvy=uy*MAX_E-e.velY;
          const dvm=Math.hypot(dvx,dvy);
          const maxF=STEER_E*ds;
          const sx=dvm>maxF?dvx/dvm*maxF:dvx;
          const sy=dvm>maxF?dvy/dvm*maxF:dvy;
          e.velX+=sx; e.velY+=sy;
          e.velX*=DAMP; e.velY*=DAMP;
          e.x+=e.velX*ds;
          e.y+=e.velY*ds;
        } else {
          e.x+=ux*MAX_E*ds;
          e.y+=uy*MAX_E*ds;
        }
        clamp(e);
      });
      separate(enemies, ds);
    }

    if(enemies.some(e=>Math.hypot(player.x-e.x,player.y-e.y)<player.r+ER)) resetGame();
​
    const elapsed=(performance.now()-pauseOffset-levelStartTime)/1000;
    if(elapsed>=levelDuration){
      const avgX=enemies.reduce((s,e)=>s+e.x,0)/enemies.length;
      const avgY=enemies.reduce((s,e)=>s+e.y,0)/enemies.length;
      level++;
      enemies.forEach(e=>e.intercept=Math.random()<0.5);
      spawnEnemy([avgX,avgY]);
      levelStartTime=performance.now()-pauseOffset;
    }
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    const elapsed=running?(performance.now()-pauseOffset-levelStartTime)/1000:0;
    const rem=Math.max(0,levelDuration-Math.floor(elapsed));
    ctx.fillStyle='#222'; ctx.font='200px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(rem,W/2,H/2);
    ctx.fillStyle='#fff'; ctx.font='36px sans-serif'; ctx.textBaseline='top';
    ctx.fillText(`Level: ${level}`,W/2,10);
    ctx.drawImage(playerImg,player.x-player.r,player.y-player.r,player.r*2,player.r*2);
    enemies.forEach(e=>{ctx.drawImage(enemyImg,e.x-ER,e.y-ER,ER*2,ER*2);});
  }

  let last=performance.now();
  (function loop(){
    const now=performance.now();
    const dt=now-last;
    update(dt);
    draw();
    last=now;
    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
