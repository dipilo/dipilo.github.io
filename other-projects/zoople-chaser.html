<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Zoople Chaser</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; display:flex; align-items:center; justify-content:center; height:100vh; font-family:sans-serif; }
    #gameContainer { position:relative; width:800px; height:600px; }
    #gameCanvas { background:#111; display:block; }
    .overlay { position:absolute; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:20px; background:rgba(0,0,0,0.7); z-index:3; }
    #settings { display:none; z-index:4; }
    button { padding:12px 24px; font-size:20px; background:rgba(255,255,255,0.1); color:#fff; border:2px solid #444; border-radius:6px; cursor:pointer; transition:background .2s; }
    button:hover { background:rgba(255,255,255,0.2); }
    .toggle, .dropdown { display:inline-block; }
    .toggle { position:relative; width:50px; height:24px; }
    .toggle input { display:none; }
    .track { position:absolute; inset:0; background:#444; border-radius:12px; transition:background .2s; }
    .thumb { position:absolute; top:2px; left:2px; width:20px; height:20px; background:#fff; border-radius:50%; transition:transform .2s; }
    .toggle input:checked + .track { background:#4caf50; }
    .toggle input:checked + .track + .thumb { transform:translateX(26px); }
    .dropdown select { appearance:none; padding:10px 40px 10px 16px; font-size:18px; background:rgba(255,255,255,0.1); color:#fff; border:2px solid #444; border-radius:6px; cursor:pointer; }
    .dropdown select option { background:#444; color:#fff; }
    .dropdown::after { content:'â–¾'; position:absolute; top:50%; right:12px; transform:translateY(-50%); color:#fff; pointer-events:none; }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="menu" class="overlay">
      <button id="playBtn">Play</button>
      <button id="settingsBtn">Settings</button>
      <button id="quitBtn">Quit</button>
    </div>
    <div id="settings" class="overlay">
      <h2 style="color:#fff; margin:0;">Settings</h2>
      <div style="color:#fff; display:flex; align-items:center; gap:10px;">
        <span>Physics Player</span>
        <label class="toggle"><input type="checkbox" id="physPlayer" /><div class="track"></div><div class="thumb"></div></label>
      </div>
      <div style="color:#fff; display:flex; align-items:center; gap:10px;">
        <span>Physics Enemies</span>
        <label class="toggle"><input type="checkbox" id="physEnemies" checked /><div class="track"></div><div class="thumb"></div></label>
      </div>
      <div style="color:#fff; display:flex; align-items:center; gap:10px;">
        <span>Difficulty</span>
        <div class="dropdown"><select id="difficultySelect"><option>Easy</option><option selected>Hard</option></select></div>
      </div>
      <button id="backBtn">Back</button>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    let physPlayer = false;
    let physEnemies = true;
    let difficulty = 'Hard';
    let paused = false;
    let running = false;
    let spawnPause = 0;

    document.getElementById('physPlayer').onchange = e => physPlayer = e.target.checked;
    document.getElementById('physEnemies').onchange = e => physEnemies = e.target.checked;
    document.getElementById('difficultySelect').onchange = e => difficulty = e.target.value;

    const playerImg = new Image(); playerImg.src = '/images/zoople-chaser/zoopleWhite.png';
    const enemyImg  = new Image(); enemyImg.src  = '/images/zoople-chaser/zooplePurple.png';

    // Speeds
    const PLAYER_PHYS_ACCEL = 600; // px/s^2
    const ENEMY_PHYS_ACCEL  = 400;
    const MAX_DAMP = 0.85;
    const PLAYER_SPEED = 300; // non-physics
    const ENEMY_SPEED  = 200;

    const player = { x: W/2, y: H/2, r: 15, velX: 0, velY: 0 };
    let enemies = [];
    const enemyR = 15;

    let level = 1;
    const levelTime = 10;
    let startTime = 0;

    const menu = document.getElementById('menu');
    const settingsMenu = document.getElementById('settings');

    document.getElementById('playBtn').onclick = () => {
      if (paused) paused = false;
      else startGame();
      menu.style.display = 'none';
    };
    document.getElementById('settingsBtn').onclick = () => { menu.style.display = 'none'; settingsMenu.style.display = 'flex'; };
    document.getElementById('backBtn').onclick = () => { settingsMenu.style.display = 'none'; menu.style.display = 'flex'; };
    document.getElementById('quitBtn').onclick = () => window.location.href = 'https://dipilo.github.io/other-projects';

    const keys = {};
    let mouseDown = false, mouseX = 0, mouseY = 0;
    window.addEventListener('keydown', e => {
      keys[e.key.toLowerCase()] = true;
      if (e.key === 'Escape' && running) { paused = !paused; menu.style.display = paused ? 'flex' : 'none'; }
    });
    window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
    canvas.addEventListener('mousedown', e => { mouseDown = true; updateMouse(e); });
    canvas.addEventListener('mouseup',   e => mouseDown = false);
    canvas.addEventListener('mousemove', e => updateMouse(e));
    function updateMouse(e) {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
    }

    function clamp(o) {
      o.x = Math.max(o.r||enemyR, Math.min(W-(o.r||enemyR), o.x));
      o.y = Math.max(o.r||enemyR, Math.min(H-(o.r||enemyR), o.y));
    }
    function separateEnemies() {
      for (let i=0;i<enemies.length;i++) for (let j=i+1;j<enemies.length;j++) {
        let a=enemies[i], b=enemies[j]; let dx=b.x-a.x, dy=b.y-a.y;
        let d=Math.hypot(dx,dy);
        if (d<2*enemyR) {
          let overlap=2*enemyR-d, ux=dx/d, uy=dy/d;
          b.x+=ux*overlap/2; b.y+=uy*overlap/2; a.x-=ux*overlap/2; a.y-=uy*overlap/2;
        }
      }
    }

    function spawnEnemy(at) {
      spawnPause = 0.2; // seconds
      enemies.forEach(e=>{e.velX=0;e.velY=0;});
      let x,y;
      do { x=Math.random()*(W-2*enemyR)+enemyR; y=Math.random()*(H-2*enemyR)+enemyR; }
      while(Math.hypot(x-player.x,y-player.y)<player.r*4);
      if(at){x=at[0]+(Math.random()*200-100);y=at[1]+(Math.random()*200-100);
        x=Math.max(enemyR,Math.min(W-enemyR,x));y=Math.max(enemyR,Math.min(H-enemyR,y));}
      enemies.push({x,y,velX:0,velY:0,intercept:Math.random()<0.5});
    }
    function resetGame(){ running=false; enemies=[]; player.x=W/2; player.y=H/2; player.velX=player.velY=0; level=1; menu.style.display='flex'; }
    function startGame(){ resetGame(); spawnEnemy(); startTime=performance.now(); running=true; paused=false; }

    function update(dt) {
      if(!running||paused) return;
      const delta=dt/1000;
      // Spawn pause
      if(spawnPause>0){ spawnPause-=delta; return; }
      // Player
      let ax=0, ay=0;
      if(keys['w']) ay--;
      if(keys['s']) ay++;
      if(keys['a']) ax--;
      if(keys['d']) ax++;
      if(mouseDown){ let dx=mouseX-player.x,dy=mouseY-player.y,d=Math.hypot(dx,dy); if(d>0){ ax=dx/d; ay=dy/d; }}
      if(physPlayer){ player.velX+=ax*PLAYER_PHYS_ACCEL*delta; player.velY+=ay*PLAYER_PHYS_ACCEL*delta;
        player.velX*=MAX_DAMP; player.velY*=MAX_DAMP;
        player.x+=player.velX*delta; player.y+=player.velY*delta;
      } else { player.x+=ax*PLAYER_BASE_SPEED*delta; player.y+=ay*PLAYER_BASE_SPEED*delta; }
      clamp(player);
      // Enemies
      enemies.forEach(e=>{
        let tx=player.x, ty=player.y;
        if(difficulty==='Hard'&&e.intercept){ let dist=Math.hypot(player.x-e.x,player.y-e.y),t=dist/ENEMY_BASE_SPEED; tx+=player.velX*t; ty+=player.velY*t; }
        if(physEnemies){ e.velX+=(tx-e.x)*ENEMY_PHYS_ACCEL*delta; e.velY+=(ty-e.y)*ENEMY_PHYS_ACCEL*delta;
          e.velX*=MAX_DAMP; e.velY*=MAX_DAMP;
          e.x+=e.velX*delta; e.y+=e.velY*delta;
        } else { let dx=tx-e.x,dy=ty-e.y,d=Math.hypot(dx,dy); if(d>0){ e.x+=(dx/d)*ENEMY_BASE_SPEED*delta; e.y+=(dy/d)*ENEMY_BASE_SPEED*delta; }}
        clamp(e);
      });
      separateEnemies();
      // Collision
      if(enemies.some(e=>Math.hypot(player.x-e.x,player.y-e.y)<player.r+enemyR)) resetGame();
      // Level
      const elapsed=(performance.now()-startTime)/1000;
      if(elapsed>=levelTime){ let avgX=enemies.reduce((s,e)=>s+e.x,0)/enemies.length;
        let avgY=enemies.reduce((s,e)=>s+e.y,0)/enemies.length;
        level++; enemies.forEach(e=>e.intercept=Math.random()<0.5);
        spawnEnemy([avgX,avgY]); startTime=performance.now(); }
    }

    function draw(){ ctx.clearRect(0,0,W,H);
      const elapsed=running?(performance.now()-startTime)/1000:0; const rem=Math.max(0,levelTime-Math.floor(elapsed));
      ctx.fillStyle='#222';ctx.font='200px sans-serif';ctx.textAlign='center';ctx.textBaseline='middle'; ctx.fillText(rem,W/2,H/2);
      ctx.fillStyle='#fff';ctx.font='36px sans-serif';ctx.textBaseline='top'; ctx.fillText(`Level: ${level}`,W/2,10);
      ctx.drawImage(playerImg,player.x-player.r,player.y-player.r,player.r*2,player.r*2);
      enemies.forEach(e=>ctx.drawImage(enemyImg,e.x-enemyR,e.y-enemyR,enemyR*2,enemyR*2)); }

    let last=performance.now(); (function loop(){ let now=performance.now(),dt=now-last; update(dt); draw(); last=now; requestAnimationFrame(loop); })();
  </script>
</body>
</html>
