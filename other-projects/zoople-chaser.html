<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Zoople Chaser</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; display:flex; align-items:center; justify-content:center; height:100vh; font-family:sans-serif; }
    #gameContainer { position:relative; width:800px; height:600px; }
    #gameCanvas { background:#111; display:block; }
    .overlay { position:absolute; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:20px; background:rgba(0,0,0,0.7); z-index:3; }
    #settings { display:none; z-index:4; }
    button { padding:12px 24px; font-size:20px; background:rgba(255,255,255,0.1); color:#fff; border:2px solid #444; border-radius:6px; cursor:pointer; transition:background .2s; }
    button:hover { background:rgba(255,255,255,0.2); }
    .toggle, .dropdown { display:inline-block; }
    .toggle { position:relative; width:50px; height:24px; }
    .toggle input { display:none; }
    .track { position:absolute; inset:0; background:#444; border-radius:12px; transition:background .2s; }
    .thumb { position:absolute; top:2px; left:2px; width:20px; height:20px; background:#fff; border-radius:50%; transition:transform .2s; }
    .toggle input:checked + .track { background:#4caf50; }
    .toggle input:checked + .track + .thumb { transform:translateX(26px); }
    .dropdown select { appearance:none; padding:10px 40px 10px 16px; font-size:18px; background:rgba(255,255,255,0.1); color:#fff; border:2px solid #444; border-radius:6px; cursor:pointer; }
    .dropdown select option { background:#444; color:#fff; }
    .dropdown::after { content:'â–¾'; position:absolute; top:50%; right:12px; transform:translateY(-50%); color:#fff; pointer-events:none; }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="menu" class="overlay">
      <button id="playBtn">Play</button>
      <button id="settingsBtn">Settings</button>
      <button id="quitBtn">Quit</button>
    </div>
    <div id="settings" class="overlay">
      <h2 style="color:#fff; margin:0;">Settings</h2>
      <div style="color:#fff; display:flex; align-items:center; gap:10px;"><span>Physics Player</span>
        <label class="toggle"><input type="checkbox" id="physPlayer" /><div class="track"></div><div class="thumb"></div></label>
      </div>
      <div style="color:#fff; display:flex; align-items:center; gap:10px;"><span>Physics Enemies</span>
        <label class="toggle"><input type="checkbox" id="physEnemies" checked /><div class="track"></div><div class="thumb"></div></label>
      </div>
      <div style="color:#fff; display:flex; align-items:center; gap:10px;"><span>Difficulty</span>
        <div class="dropdown"><select id="difficultySelect"><option value="Easy">Easy</option><option value="Hard" selected>Hard</option></select></div>
      </div>
      <button id="backBtn">Back</button>
    </div>
  </div>

  <script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  let physPlayer = false, physEnemies = true, difficulty = 'Hard';
  let paused = false, running = false, spawnPause = 0;
  let pauseStart = 0, pauseOffset = 0;

  document.getElementById('physPlayer').onchange = e => physPlayer = e.target.checked;
  document.getElementById('physEnemies').onchange = e => physEnemies = e.target.checked;
  document.getElementById('difficultySelect').onchange = e => difficulty = e.target.value;

  document.getElementById('playBtn').onclick = () => {
    if(running && paused) { paused = false; pauseOffset += performance.now() - pauseStart; toggle('menu', false); }
    else { startGame(); toggle('menu', false); }
  };
  document.getElementById('settingsBtn').onclick = () => { toggle('menu', false); toggle('settings', true); };
  document.getElementById('backBtn').onclick = () => { toggle('settings', false); toggle('menu', true); };
  document.getElementById('quitBtn').onclick = () => window.location.href = 'https://dipilo.github.io/other-projects';
  function toggle(id, show) { document.getElementById(id).style.display = show ? 'flex' : 'none'; }

  const playerImg = new Image(); playerImg.src = '/images/zoople-chaser/zoopleWhite.png';
  const enemyImg  = new Image(); enemyImg.src  = '/images/zoople-chaser/zooplePurple.png';
  const dingSound = new Audio('/sounds/ding.mp3');

  // Steering & separation parameters
  const MAX_SPEED_P = 400, MAX_SPEED_E = 250;
  const STEER_FORCE_P = 8000, STEER_FORCE_E = 6000;
  const DAMPING = 0.92;
  const INTERCEPT_CONE = Math.cos(Math.PI/6);
  const SEPARATION_RADIUS = 40;
  const SEPARATION_FORCE = 12000;

  const player = { x: W/2, y: H/2, r: 15, velX:0, velY:0 };
  let enemies = [];
  const ER = 15;
  let level = 1, levelDuration = 10, levelStartTime = 0;

  const keys = {};
  let mouseDown=false, mouseX=0, mouseY=0;
  window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true;
    if(e.key==='Escape'&&running){ paused=!paused; if(paused) pauseStart=performance.now(); toggle('menu', paused);} });
  window.addEventListener('keyup', e => keys[e.key.toLowerCase()]=false);
  canvas.addEventListener('mousedown', e=>{ if(e.button===0){ mouseDown=true; updateMouse(e); }});
  window.addEventListener('mouseup', ()=>mouseDown=false);
  canvas.addEventListener('mousemove', updateMouse);
  function updateMouse(e){ const r=canvas.getBoundingClientRect(); mouseX=e.clientX-r.left; mouseY=e.clientY-r.top; }

  function clamp(o){ o.x=Math.max(o.r||ER,Math.min(W-(o.r||ER),o.x)); o.y=Math.max(o.r||ER,Math.min(H-(o.r||ER),o.y)); }
  function separateArray(arr){ arr.forEach((a,i)=>{ arr.forEach((b,j)=>{ if(i!==j){ const dx=a.x-b.x, dy=a.y-b.y, d=Math.hypot(dx,dy);
      if(d<SEPARATION_RADIUS&&d>0){ const overlap=(SEPARATION_RADIUS-d)/d; a.velX+=dx*overlap*SEPARATION_FORCE/100000; a.velY+=dy*overlap*SEPARATION_FORCE/100000; } }}); }); }

  function spawnEnemy(at){ spawnPause=0.2; enemies.forEach(e=>{e.velX=0;e.velY=0;}); dingSound.play();
    let x,y; do{ x=Math.random()*(W-2*ER)+ER; y=Math.random()*(H-2*ER)+ER;}while(Math.hypot(x-player.x,y-player.y)<player.r*4);
    if(at){ x=at[0]+(Math.random()*200-100); y=at[1]+(Math.random()*200-100); x=Math.max(ER,Math.min(W-ER,x)); y=Math.max(ER,Math.min(H-ER,y)); }
    enemies.push({x,y,velX:0,velY:0,intercept: Math.random()<0.5}); }

  function resetGame(){ running=false; enemies=[]; player.x=W/2; player.y=H/2; player.velX=0; player.velY=0; level=1; pauseOffset=0; toggle('menu', true); }
  function startGame(){ resetGame(); spawnEnemy(); levelStartTime=performance.now(); running=true; paused=false; }

  function update(dt){ if(!running||paused) return; const ds=dt/1000;
    // Player steering
    let ax=0,ay=0; if(keys['w'])ay--; if(keys['s'])ay++; if(keys['a'])ax--; if(keys['d'])ax++;
    if(mouseDown){ const dx=mouseX-player.x, dy=mouseY-player.y, d=Math.hypot(dx,dy); if(d>0){ax=dx/d;ay=dy/d;}}
    if(physPlayer){ const dvx=ax*MAX_SPEED_P-player.velX, dvy=ay*MAX_SPEED_P-player.velY; const dvm=Math.hypot(dvx,dvy);
      const maxF=STEER_FORCE_P*ds; const sx=dvm>maxF?dvx/dvm*maxF:dvx, sy=dvm>maxF?dvy/dvm*maxF:dvy;
      player.velX+=sx; player.velY+=sy; player.velX*=DAMPING; player.velY*=DAMPING;
      player.x+=player.velX*ds; player.y+=player.velY*ds;
    } else { player.x+=ax*MAX_SPEED_P*ds; player.y+=ay*MAX_SPEED_P*ds; }
    clamp(player);

    // Enemy steering + separation
    if(spawnPause>0) spawnPause-=ds; else{
      enemies.forEach(e=>{
        let tx=player.x,ty=player.y;
        if(difficulty==='Hard'&&e.intercept){ const lead=0.5; const ix=player.x+player.velX*lead, iy=player.y+player.velY*lead;
          const distD=Math.hypot(player.x-e.x,player.y-e.y), distI=Math.hypot(ix-e.x,iy-e.y);
          const ux_e=(player.x-e.x)/distD, uy_e=(player.y-e.y)/distD;
          const pv=Math.hypot(player.velX,player.velY);
          const upx=pv>0?player.velX/pv:0, upy=pv>0?player.velY/pv:0;
          const dot=ux_e*upx+uy_e*upy;
          if(!(distD<distI||dot>INTERCEPT_CONE)) { tx=(player.x+ix)*0.5; ty=(player.y+iy)*0.5; }
        }
        const dx=tx-e.x,dy=ty-e.y,d=Math.hypot(dx,dy), ux=d>0?dx/d:0, uy=d>0?dy/d:0;
        if(physEnemies){ const dvx=ux*MAX_SPEED_E-e.velX, dvy=uy*MAX_SPEED_E-e.velY, dvm=Math.hypot(dvx,dvy);
          const maxF=STEER_FORCE_E*ds; const sx=dvm>maxF?dvx/dvm*maxF:dvx, sy=dvm>maxF?dvy/dvm*maxF:dvy;
          e.velX+=sx; e.velY+=sy; e.velX*=DAMPING; e.velY*=DAMPING;
          e.x+=e.velX*ds; e.y+=e.velY*ds;
        } else { e.x+=ux*MAX_SPEED_E*ds; e.y+=uy*MAX_SPEED_E*ds; }
        clamp(e);
      });
      // apply separation force
      separateArray(enemies);
    }
    separate();
    if(enemies.some(e=>Math.hypot(player.x-e.x,player.y-e.y)<player.r+ER)) resetGame();

    const elapsed=(performance.now()-pauseOffset-levelStartTime)/1000;
    if(elapsed>=levelDuration){ const avgX=enemies.reduce((s,e)=>s+e.x,0)/enemies.length;
      const avgY=enemies.reduce((s,e)=>s+e.y,0)/enemies.length; level++; enemies.forEach(e=>e.intercept=Math.random()<0.5);
      spawnEnemy([avgX,avgY]); levelStartTime=performance.now()-pauseOffset; }
  }

  function draw(){ ctx.clearRect(0,0,W,H);
    const elapsed=running?(performance.now()-pauseOffset-levelStartTime)/1000:0;
    const rem=Math.max(0,levelDuration-Math.floor(elapsed));
    ctx.fillStyle='#222';ctx.font='200px sans-serif';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText(rem,W/2,H/2);
    ctx.fillStyle='#fff';ctx.font='36px sans-serif';ctx.textBaseline='top';ctx.fillText(`Level: ${level}`,W/2,10);
    ctx.drawImage(playerImg,player.x-player.r,player.y-player.r,player.r*2,player.r*2);
    enemies.forEach(e=>{ctx.drawImage(enemyImg,e.x-ER,e.y-ER,ER*2,ER*2);});
  }

  let last=performance.now(); (function loop(){ const now=performance.now(), dt=now-last; update(dt); draw(); last=now; requestAnimationFrame(loop); })();
  </script>
</body>
</html>
